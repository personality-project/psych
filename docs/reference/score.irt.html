<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Find Item Response Theory (IRT) based scores for dichotomous or polytomous items — scoreIrt • psych</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">


<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>

<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">psych</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Find Item Response Theory (IRT) based scores for dichotomous or polytomous items</h1>
    </div>

    
    <p><code><a href='irt.fa.html'>irt.fa</a></code> finds Item Response Theory (IRT) parameters through factor analysis of the tetrachoric or polychoric correlations of dichtomous or polytomous items. <code>scoreIrt</code> uses these parameter estimates of discrimination and location to find IRT based scores for the responses. As many factors as found for the correlation matrix will be scored. <code>scoreIrt.2pl</code> will score lists of scales.</p>
    

    <pre class="usage"><span class='fu'>scoreIrt</span>(<span class='kw'>stats</span><span class='kw'>=</span><span class='kw'>NULL</span>, <span class='no'>items</span>, <span class='kw'>keys</span><span class='kw'>=</span><span class='kw'>NULL</span>,<span class='kw'>cut</span> <span class='kw'>=</span> <span class='fl'>0.3</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='fu'>c</span>(-<span class='fl'>4</span>,<span class='fl'>4</span>),<span class='kw'>mod</span><span class='kw'>=</span><span class='st'>"logistic"</span>)
<span class='fu'>scoreIrt.1pl</span>(<span class='no'>keys.list</span>,<span class='no'>items</span>,<span class='kw'>correct</span><span class='kw'>=</span><span class='fl'>.5</span>,<span class='kw'>messages</span><span class='kw'>=</span><span class='fl'>FALSE</span>,<span class='kw'>cut</span><span class='kw'>=</span><span class='fl'>.3</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='fu'>c</span>(-<span class='fl'>4</span>,<span class='fl'>4</span>),
     <span class='kw'>mod</span><span class='kw'>=</span><span class='st'>"logistic"</span>)  <span class='co'>#Rasch like scaling</span>
<span class='fu'>scoreIrt.2pl</span>(<span class='no'>itemLists</span>,<span class='no'>items</span>,<span class='kw'>correct</span><span class='kw'>=</span><span class='fl'>.5</span>,<span class='kw'>messages</span><span class='kw'>=</span><span class='fl'>FALSE</span>,<span class='kw'>cut</span><span class='kw'>=</span><span class='fl'>.3</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='fu'>c</span>(-<span class='fl'>4</span>,<span class='fl'>4</span>),
   <span class='kw'>mod</span><span class='kw'>=</span><span class='st'>"logistic"</span>)  <span class='co'>#2 pl scoring</span>
<span class='co'>#the next is an alias for scoreIrt both of which are wrappers for </span>
<span class='co'>#     score.irt.2 and score.irt.poly</span>
<span class='fu'>score.irt</span>(<span class='kw'>stats</span><span class='kw'>=</span><span class='kw'>NULL</span>, <span class='no'>items</span>, <span class='kw'>keys</span><span class='kw'>=</span><span class='kw'>NULL</span>,<span class='kw'>cut</span> <span class='kw'>=</span> <span class='fl'>0.3</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='fu'>c</span>(-<span class='fl'>4</span>,<span class='fl'>4</span>),<span class='kw'>mod</span><span class='kw'>=</span><span class='st'>"logistic"</span>)
 <span class='co'>#the higher order call just calls one of the next two</span>
  <span class='co'>#for dichotomous items </span>
<span class='fu'>score.irt.2</span>(<span class='no'>stats</span>, <span class='no'>items</span>,<span class='kw'>keys</span><span class='kw'>=</span><span class='kw'>NULL</span>,<span class='kw'>cut</span> <span class='kw'>=</span> <span class='fl'>0.3</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='fu'>c</span>(-<span class='fl'>4</span>,<span class='fl'>4</span>),<span class='kw'>mod</span><span class='kw'>=</span><span class='st'>"logistic"</span>)
  <span class='co'>#for polytomous items</span>
<span class='fu'>score.irt.poly</span>(<span class='no'>stats</span>, <span class='no'>items</span>, <span class='kw'>keys</span><span class='kw'>=</span><span class='kw'>NULL</span>, <span class='kw'>cut</span> <span class='kw'>=</span> <span class='fl'>0.3</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='fu'>c</span>(-<span class='fl'>4</span>,<span class='fl'>4</span>),<span class='kw'>mod</span><span class='kw'>=</span><span class='st'>"logistic"</span>)
    <span class='co'>#to create irt like statistics for plotting</span>
<span class='fu'>irt.stats.like</span>(<span class='no'>items</span>,<span class='no'>stats</span>,<span class='kw'>keys</span><span class='kw'>=</span><span class='kw'>NULL</span>,<span class='kw'>cut</span><span class='kw'>=</span><span class='fl'>.3</span>)

<span class='fu'>irt.tau</span>(<span class='no'>x</span>)    <span class='co'>#find the tau values for the x object</span>
<span class='fu'>irt.se</span>(<span class='no'>stats</span>,<span class='kw'>scores</span><span class='kw'>=</span><span class='fl'>0</span>,<span class='kw'>D</span><span class='kw'>=</span><span class='fl'>1.702</span>)</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a> Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>stats</th>
      <td><p>Output from irt.fa is used for parameter estimates of location and discrimination. Stats may also be the  output from a normal factor analysis (fa)</p></td>
    </tr>
    <tr>
      <th>items</th>
      <td><p>The raw data, may be either dichotomous or polytomous.</p></td>
    </tr>
    <tr>
      <th>itemLists</th>
      <td><p>a list of items to be factored and scored for each scale, can be a keys.list as used in scoreItems or scoreIrt.1pl</p></td>
    </tr>
    <tr>
      <th>keys.list</th>
      <td><p>A list of items to be scored with keying direction  (see example)</p></td>
    </tr>
    <tr>
      <th>keys</th>
      <td><p>A keys matrix of which items should be scored for each factor</p></td>
    </tr>
    <tr>
      <th>cut</th>
      <td><p>Only items with discrimination values &gt; cut will be used for scoring.</p></td>
    </tr>
    <tr>
      <th>x</th>
      <td><p>The raw data to be used to find the tau parameter in irt.tau</p></td>
    </tr>
    <tr>
      <th>bounds</th>
      <td><p>The lower and upper estimates for the fitting function</p></td>
    </tr>
    <tr>
      <th>mod</th>
      <td><p>Should a logistic or normal model be used in estimating the scores?</p></td>
    </tr>
    <tr>
      <th>correct</th>
      <td><p>What value should be used for continuity correction when finding the
     tetrachoric or polychoric correlations when using irt.fa</p></td>
    </tr>
    <tr>
      <th>messages</th>
      <td><p>Should messages be suppressed when running multiple scales?</p></td>
    </tr>
    <tr>
      <th>scores</th>
      <td><p>A single score or a vector of scores to find standard errors</p></td>
    </tr>
    <tr>
      <th>D</th>
      <td><p>The scaling function for the test information statistic used in irt.se</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>Although there are more elegant ways of finding subject scores given a set of item locations (difficulties) and discriminations, simply finding that value of theta \(\theta\) that best fits the equation \(P(x|\theta) = 1/(1+exp(\beta(\delta - \theta) )\) for a score vector X, and location \(\delta\) and discrimination \(\beta\) provides more information than just total scores.  With complete data, total scores and irt estimates are almost perfectly correlated.  However, the irt estimates provide much more information in the case of missing data.</p>
<p>The bounds parameter sets the lower and upper limits to the estimate.  This is relevant for the case of a subject who gives just the lowest score on every item, or just the top score on every item. Formerly (prior to 1.6.12) this was done by  estimating these taial scores  by finding the probability of missing every item taken, converting this to a quantile score based upon the normal distribution, and then assigning a z value equivalent to 1/2 of that quantile.  Similarly, if a person gets all the items they take correct, their score is defined as the quantile of the z equivalent to the probability of getting all of the items correct, and then moving up the distribution half way.  If these estimates exceed either the upper or lower bounds, they are adjusted to those boundaries.</p>
<p>As of 1.6.9, the procedure is very different.  We now assume that all items are bounded with one passed item that is easier than all items given, and one failed item that is harder than any item given.  This produces much cleaner results.</p>
<p>There are several more elegant packages in R that provide Full Information Maximum Likeliood IRT based estimates. In particular, the MIRT package seems especially good.  The ltm package give equivalent estimates to MIRT for dichotomous data but produces unstable estimates for polytomous data and should be avoided.</p>
<p>Although the scoreIrt estimates are are not FIML based they seem to correlated with  the MIRT estiamtes with values exceeding .99.  Indeed, based upon very limited simulations there are some small hints that the solutions match the true score estimates  slightly better than do the MIRT estimates.  <code>scoreIrt</code> seems to do a good job of recovering the basic structure.</p>
<p>The two wrapper functions <code>scoreIrt.1pl</code> and <code>scoreIrt.2pl</code> are very fast and are meant for scoring one or many scales at a time with a one factor model (<code>scoreIrt.2pl</code>) or just Rasch like scoring.  Just specify the scoring direction for a number of scales  (<code>scoreIrt.1pl</code>) or just items to score  for a number of scales <code>scoreIrt.2pl</code>.  <code>scoreIrt.2pl</code> will then apply <code><a href='irt.fa.html'>irt.fa</a></code> to the items for each scale separately, and then find the 2pl scores.</p>
<p>The keys.list is a list of items to score for each scale.  Preceding the item name with a negative sign will reverse score that item (relevant for <code>scoreIrt.1pl</code>.  Alternatively, a keys matrix can be created using <code><a href='make.keys.html'>make.keys</a></code>.  The keys matrix is a matrix of 1s, 0s, and -1s reflecting whether an item should be scored or not scored for a particular factor.  See <code><a href='score.items.html'>scoreItems</a></code> or <code><a href='make.keys.html'>make.keys</a></code> for details.  The default case is to score all items with absolute discriminations &gt; cut.</p>
    <p>If one wants to score scales taking advantage of differences in item location but not do a full IRT analysis, then find the item difficulties from the raw data using <code>irt.tau</code> or combine this information with a scoring keys matrix (see <code><a href='score.items.html'>scoreItems</a></code> and <code><a href='make.keys.html'>make.keys</a></code> and create quasi-IRT statistics using <code>irt.stats.like</code>.   This is the equivalent of doing a quasi-Rasch model, in that all items are assumed to be equally discriminating.  In this case, tau values may be found first (using <code>irt.tau</code> or just found before doing the scoring.  This is all done for you inside of <code>scoreIrt.1pl</code>.</p>
<p>Such irt based scores are particularly useful if finding scales based upon massively missing data (e.g., the SAPA data sets).  Even without doing the full irt analysis, we can take into account different item difficulties.</p>
<p>David Condon has added a very nice function to do 2PL analysis for a number of scales at one time.  <code>scoreIrt.2pl</code> takes the raw data file and a list of items to score for each of multiple scales.  These are then factored (currently just one factor for each scale) and the loadings and difficulties are used for scoring.</p>
<p>There are conventionally two different metrics and models that are used.  The logistic metric and model and the normal metric and model. These are chosen using the mod parameter.
    <code>irt.se</code> finds the standard errors for scores with a particular value.  These are based upon the information curves calculated by <code><a href='irt.fa.html'>irt.fa</a></code> and are not based upon the particular score of a particular subject.</p>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p></p>
<dt>scores</dt><dd><p>A data frame of theta estimates, total scores based upon raw sums, and estimates of fit.</p></dd>
 <dt>tau</dt><dd><p>Returned by irt.tau: A data frame of the tau values for an object of dichotomous or polytomous items.  Found without bothering to find the correlations.</p></dd>

    
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Kamata, Akihito and Bauer, Daniel J. (2008) A Note on the Relation Between Factor Analytic and Item Response Theory Models
Structural Equation Modeling, 15 (1) 136-153.
    McDonald, Roderick P. (1999) Test theory: A unified treatment. L. Erlbaum Associates.</p>
<p>Revelle, William. (in prep) An introduction to psychometric theory with applications in R. Springer.  Working draft available at <a href = 'http://personality-project.org/r/book/'>http://personality-project.org/r/book/</a></p>
    
    <h2 class="hasAnchor" id="note"><a class="anchor" href="#note"></a>Note</h2>

    <p>It is very important to note that when using <code><a href='irt.fa.html'>irt.fa</a></code> to find the discriminations, to set the sort option to be FALSE. This is now the default.  Otherwise, the discriminations will not match the item order.</p>
<p>Always under development.  Suggestions for improvement are most appreciated.</p>
<p>scoreIrt is just a wrapper to score.irt.poly and score.irt.2.  The previous version had score.irt which is now deprecated as I try to move to camelCase.</p>
<p>scoreIrt.2pl is a wrapper for irt.fa and scoreIrt.  It was originally developed by David Condon.</p>
    
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <p><code><a href='irt.fa.html'>irt.fa</a></code> for finding the parameters. For more conventional scoring algorithms see <code><a href='score.items.html'>scoreItems</a></code>. <code><a href='irt.responses.html'>irt.responses</a></code> will plot the empirical response patterns for the alternative response choices for  multiple choice items. For more conventional IRT estimations, see the ltm package.</p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='kw'>if</span>(<span class='fl'>FALSE</span>) {  <span class='co'>#not run in the interest of time, but worth doing</span>
<span class='no'>d9</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='sim.html'>sim.irt</a></span>(<span class='fl'>9</span>,<span class='fl'>1000</span>,-<span class='fl'>2.5</span>,<span class='fl'>2.5</span>,<span class='kw'>mod</span><span class='kw'>=</span><span class='st'>"normal"</span>) <span class='co'>#dichotomous items</span>
<span class='no'>test</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='irt.fa.html'>irt.fa</a></span>(<span class='no'>d9</span>$<span class='no'>items</span>)
<span class='no'>scores</span> <span class='kw'>&lt;-</span> <span class='fu'>scoreIrt</span>(<span class='no'>test</span>,<span class='no'>d9</span>$<span class='no'>items</span>)
<span class='no'>scores.df</span> <span class='kw'>&lt;-</span> <span class='fu'>data.frame</span>(<span class='no'>scores</span>,<span class='kw'>true</span><span class='kw'>=</span><span class='no'>d9</span>$<span class='no'>theta</span>) <span class='co'>#combine the estimates with the true thetas.</span>
<span class='fu'><a href='pairs.panels.html'>pairs.panels</a></span>(<span class='no'>scores.df</span>,<span class='kw'>pch</span><span class='kw'>=</span><span class='st'>"."</span>,
<span class='kw'>main</span><span class='kw'>=</span><span class='st'>"Comparing IRT and classical with complete data"</span>)
<span class='co'>#now show how to do this with a quasi-Rasch model</span>
<span class='no'>tau</span> <span class='kw'>&lt;-</span> <span class='fu'>irt.tau</span>(<span class='no'>d9</span>$<span class='no'>items</span>)
<span class='no'>scores.rasch</span> <span class='kw'>&lt;-</span> <span class='fu'>scoreIrt</span>(<span class='no'>tau</span>,<span class='no'>d9</span>$<span class='no'>items</span>,<span class='kw'>key</span><span class='kw'>=</span><span class='fu'>rep</span>(<span class='fl'>1</span>,<span class='fl'>9</span>))
<span class='no'>scores.dfr</span><span class='kw'>&lt;-</span> <span class='fu'>data.frame</span>(<span class='no'>scores.df</span>,<span class='no'>scores.rasch</span>) <span class='co'>#almost identical to 2PL model!</span>
<span class='fu'><a href='pairs.panels.html'>pairs.panels</a></span>(<span class='no'>scores.dfr</span>)
<span class='co'>#with all the data, why bother ?</span>

<span class='co'>#now delete some of the data</span>
<span class='no'>d9</span>$<span class='no'>items</span>[<span class='fl'>1</span>:<span class='fl'>333</span>,<span class='fl'>1</span>:<span class='fl'>3</span>] <span class='kw'>&lt;-</span> <span class='fl'>NA</span>
<span class='no'>d9</span>$<span class='no'>items</span>[<span class='fl'>334</span>:<span class='fl'>666</span>,<span class='fl'>4</span>:<span class='fl'>6</span>] <span class='kw'>&lt;-</span> <span class='fl'>NA</span>
<span class='no'>d9</span>$<span class='no'>items</span>[<span class='fl'>667</span>:<span class='fl'>1000</span>,<span class='fl'>7</span>:<span class='fl'>9</span>] <span class='kw'>&lt;-</span> <span class='fl'>NA</span>
<span class='no'>scores</span> <span class='kw'>&lt;-</span> <span class='fu'>scoreIrt</span>(<span class='no'>test</span>,<span class='no'>d9</span>$<span class='no'>items</span>)
<span class='no'>scores.df</span> <span class='kw'>&lt;-</span> <span class='fu'>data.frame</span>(<span class='no'>scores</span>,<span class='kw'>true</span><span class='kw'>=</span><span class='no'>d9</span>$<span class='no'>theta</span>) <span class='co'>#combine the estimates with the true thetas.</span>
<span class='fu'><a href='pairs.panels.html'>pairs.panels</a></span>(<span class='no'>scores.df</span>, <span class='kw'>pch</span><span class='kw'>=</span><span class='st'>"."</span>,
<span class='kw'>main</span><span class='kw'>=</span><span class='st'>"Comparing IRT and classical with random missing data"</span>)
 <span class='co'>#with missing data, the theta estimates are noticably better.</span>
<span class='co'>#now show how to do this with a quasi-Rasch model</span>
<span class='no'>tau</span> <span class='kw'>&lt;-</span> <span class='fu'>irt.tau</span>(<span class='no'>d9</span>$<span class='no'>items</span>)
<span class='no'>scores.rasch</span> <span class='kw'>&lt;-</span> <span class='fu'>scoreIrt</span>(<span class='no'>tau</span>,<span class='no'>d9</span>$<span class='no'>items</span>,<span class='kw'>key</span><span class='kw'>=</span><span class='fu'>rep</span>(<span class='fl'>1</span>,<span class='fl'>9</span>))
<span class='no'>scores.dfr</span> <span class='kw'>&lt;-</span> <span class='fu'>data.frame</span>(<span class='no'>scores.df</span>,<span class='kw'>rasch</span> <span class='kw'>=</span> <span class='no'>scores.rasch</span>)
<span class='fu'><a href='pairs.panels.html'>pairs.panels</a></span>(<span class='no'>scores.dfr</span>)  <span class='co'>#rasch is actually better!</span>



<span class='no'>v9</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='sim.html'>sim.irt</a></span>(<span class='fl'>9</span>,<span class='fl'>1000</span>,-<span class='fl'>2.</span>,<span class='fl'>2.</span>,<span class='kw'>mod</span><span class='kw'>=</span><span class='st'>"normal"</span>) <span class='co'>#dichotomous items</span>
<span class='no'>items</span> <span class='kw'>&lt;-</span> <span class='no'>v9</span>$<span class='no'>items</span>
<span class='no'>test</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='irt.fa.html'>irt.fa</a></span>(<span class='no'>items</span>)
<span class='no'>total</span> <span class='kw'>&lt;-</span> <span class='fu'>rowSums</span>(<span class='no'>items</span>)
<span class='no'>ord</span> <span class='kw'>&lt;-</span> <span class='fu'>order</span>(<span class='no'>total</span>)
<span class='no'>items</span> <span class='kw'>&lt;-</span> <span class='no'>items</span>[<span class='no'>ord</span>,]


<span class='co'>#now delete some of the data - note that they are ordered by score</span>
<span class='no'>items</span>[<span class='fl'>1</span>:<span class='fl'>333</span>,<span class='fl'>5</span>:<span class='fl'>9</span>] <span class='kw'>&lt;-</span> <span class='fl'>NA</span>
<span class='no'>items</span>[<span class='fl'>334</span>:<span class='fl'>666</span>,<span class='fl'>3</span>:<span class='fl'>7</span>] <span class='kw'>&lt;-</span> <span class='fl'>NA</span>
<span class='no'>items</span>[<span class='fl'>667</span>:<span class='fl'>1000</span>,<span class='fl'>1</span>:<span class='fl'>4</span>] <span class='kw'>&lt;-</span> <span class='fl'>NA</span>
<span class='no'>items</span>[<span class='fl'>990</span>:<span class='fl'>995</span>,<span class='fl'>1</span>:<span class='fl'>9</span>] <span class='kw'>&lt;-</span> <span class='fl'>NA</span>   <span class='co'>#the case of terrible data</span>
<span class='no'>items</span>[<span class='fl'>996</span>:<span class='fl'>998</span>,] <span class='kw'>&lt;-</span> <span class='fl'>0</span>   <span class='co'>#all wrong</span>
<span class='no'>items</span>[<span class='fl'>999</span>:<span class='fl'>1000</span>] <span class='kw'>&lt;-</span> <span class='fl'>1</span>   <span class='co'>#all right</span>
<span class='no'>scores</span> <span class='kw'>&lt;-</span> <span class='fu'>scoreIrt</span>(<span class='no'>test</span>,<span class='no'>items</span>)
<span class='no'>unitweighted</span> <span class='kw'>&lt;-</span> <span class='fu'>scoreIrt</span>(<span class='kw'>items</span><span class='kw'>=</span><span class='no'>items</span>,<span class='kw'>keys</span><span class='kw'>=</span><span class='fu'>rep</span>(<span class='fl'>1</span>,<span class='fl'>9</span>)) <span class='co'>#each item has a discrimination of 1</span>
<span class='co'>#combine the estimates with the true thetas.</span>
<span class='no'>scores.df</span> <span class='kw'>&lt;-</span> <span class='fu'>data.frame</span>(<span class='no'>v9</span>$<span class='no'>theta</span>[<span class='no'>ord</span>],<span class='no'>scores</span>,<span class='no'>unitweighted</span>)

<span class='fu'>colnames</span>(<span class='no'>scores.df</span>) <span class='kw'>&lt;-</span> <span class='fu'>c</span>(<span class='st'>"True theta"</span>,<span class='st'>"irt theta"</span>,<span class='st'>"total"</span>,<span class='st'>"fit"</span>,<span class='st'>"rasch"</span>,<span class='st'>"total"</span>,<span class='st'>"fit"</span>)
<span class='fu'><a href='pairs.panels.html'>pairs.panels</a></span>(<span class='no'>scores.df</span>,<span class='kw'>pch</span><span class='kw'>=</span><span class='st'>"."</span>,<span class='kw'>main</span><span class='kw'>=</span><span class='st'>"Comparing IRT and classical with missing data"</span>)
 <span class='co'>#with missing data, the theta estimates are noticably better estimates </span>
 <span class='co'>#of the generating theta than using the empirically derived factor loading weights</span>

<span class='co'>#now show the ability to score multiple scales using keys</span>
<span class='no'>ab.tau</span> <span class='kw'>&lt;-</span> <span class='fu'>irt.tau</span>(<span class='no'>ability</span>)  <span class='co'>#first find the tau values</span>
<span class='no'>ab.keys</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='make.keys.html'>make.keys</a></span>(<span class='no'>ability</span>,<span class='fu'>list</span>(<span class='kw'>g</span><span class='kw'>=</span><span class='fl'>1</span>:<span class='fl'>16</span>,<span class='kw'>reason</span><span class='kw'>=</span><span class='fl'>1</span>:<span class='fl'>4</span>,<span class='kw'>letter</span><span class='kw'>=</span><span class='fl'>5</span>:<span class='fl'>8</span>,<span class='kw'>matrix</span><span class='kw'>=</span><span class='fl'>9</span>:<span class='fl'>12</span>,<span class='kw'>rotate</span><span class='kw'>=</span><span class='fl'>13</span>:<span class='fl'>16</span>))
<span class='no'>ab.scores</span> <span class='kw'>&lt;-</span> <span class='fu'>scoreIrt</span>(<span class='kw'>stats</span><span class='kw'>=</span><span class='no'>ab.tau</span>, <span class='kw'>items</span> <span class='kw'>=</span> <span class='no'>ability</span>, <span class='kw'>keys</span> <span class='kw'>=</span> <span class='no'>ab.keys</span>)

<span class='co'>#and now do it for polytomous items </span>
<span class='no'>bfi.tau</span> <span class='kw'>&lt;-</span> <span class='fu'>irt.tau</span>(<span class='no'>bfi</span>[<span class='fl'>1</span>:<span class='fl'>25</span>])
<span class='no'>bfi.keys</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='make.keys.html'>make.keys</a></span>(<span class='no'>bfi</span>[<span class='fl'>1</span>:<span class='fl'>25</span>],<span class='fu'>list</span>(<span class='kw'>agree</span><span class='kw'>=</span><span class='fu'>c</span>(-<span class='fl'>1</span>,<span class='fl'>2</span>:<span class='fl'>5</span>),<span class='kw'>conscientious</span><span class='kw'>=</span><span class='fu'>c</span>(<span class='fl'>6</span>:<span class='fl'>8</span>,-<span class='fl'>9</span>,-<span class='fl'>10</span>),
<span class='kw'>extra</span><span class='kw'>=</span><span class='fu'>c</span>(<span class='fl'>11</span>:<span class='fl'>12</span>,-<span class='fl'>13</span>,-<span class='fl'>14</span>,-<span class='fl'>15</span>),<span class='kw'>neur</span> <span class='kw'>=</span> <span class='fl'>16</span>:<span class='fl'>20</span>,<span class='kw'>open</span> <span class='kw'>=</span><span class='fu'>c</span>(<span class='fl'>21</span>,-<span class='fl'>22</span>,<span class='fl'>23</span>,<span class='fl'>24</span>,-<span class='fl'>25</span>)))
<span class='no'>bfi.scores</span> <span class='kw'>&lt;-</span> <span class='fu'>scoreIrt</span>(<span class='no'>bfi.tau</span>,<span class='no'>bfi</span>[<span class='fl'>1</span>:<span class='fl'>25</span>],<span class='no'>bfi.keys</span>)
}</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#details">Details</a></li>

      <li><a href="#value">Value</a></li>

      <li><a href="#references">References</a></li>

      <li><a href="#note">Note</a></li>

      <li><a href="#see-also">See also</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

    <h2>Author</h2>
    William Revelle, David Condon

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by William Revelle.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
